"""Функция как атрибут класса.

"""

class Car:
    model = "BMW"
    engine = 1.6

    def drive(self): # Питон разрешает внутри класса объявлять не только переменные, но и функции
        print("let's go")

""" Теперь через класс можно обращаться к функции:
        Car.drive()-> 'let's go'  #ставим (), без них мы обратимся к объекту
        
    Так же мы можем вызваться функцию через :
    getattr(Car, 'drive')-> Обращение к объекту
    для вызова используем getattr(Car, 'drive')() -> 'let's go'
"""
""" Попробуем обратиться к этой функции через экземпляр класса:
        a = Car()
        a.drive -> bound method для экземпляра 
        Car.drive -> function для Класса
        a.drive() -> Ошибка
        
    Если мы хотим написать функцию, которую можно вызывать как от самого класса, так и от его экземпляра,
    то мы должны воспользоваться декоратором  @staticmethod
"""
class Car:
    model = "BMW"
    engine = 1.6

    @staticmethod
    def drive(self):
        print("let's go")

    """ Теперь  Car.drive()-> "let's go"
         и  a.drive() ->"let's go"
    
    """